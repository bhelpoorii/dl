import pandas as pd

# Read the CSV file
df = pd.read_csv("your_file.csv")

# Print the entire content
print(df)

# Print first 5 rows (optional)
print(df.head())
## for numerical mapping 
#df["target"] = df["target"].map({"No": 0, "Yes": 1})


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.datasets import load_breast_cancer
import warnings
warnings.filterwarnings('ignore')

# =====================================================
# Neural Network Class
# =====================================================
class NeuralNetwork:
    def __init__(self, input_size, hidden_size, output_size, dropout_rate=0.1):
        self.W1 = np.random.randn(input_size, hidden_size) * 0.01
        self.b1 = np.zeros((1, hidden_size))
        self.W2 = np.random.randn(hidden_size, output_size) * 0.01
        self.b2 = np.zeros((1, output_size))

        self.dropout_rate = dropout_rate
        self.training = True

    def sigmoid(self, z):
        z = np.clip(z, -500, 500)
        return 1 / (1 + np.exp(-z))

    def sigmoid_derivative(self, z):
        return z * (1 - z)

    def dropout(self, X):
        if self.training and self.dropout_rate > 0:
            mask = np.random.binomial(1, 1 - self.dropout_rate, X.shape) / (1 - self.dropout_rate)
            return X * mask, mask
        return X, np.ones_like(X)

    def forward(self, X):
        self.z1 = np.dot(X, self.W1) + self.b1
        self.a1 = self.sigmoid(self.z1)

        self.a1_dropout, self.dropout_mask = self.dropout(self.a1)

        self.z2 = np.dot(self.a1_dropout, self.W2) + self.b2
        self.a2 = self.sigmoid(self.z2)
        return self.a2

    def compute_loss(self, y_true, y_pred):
        epsilon = 1e-15
        y_pred = np.clip(y_pred, epsilon, 1 - epsilon)
        return -np.mean(y_true * np.log(y_pred) + (1 - y_true) * np.log(1 - y_pred))

    def backward(self, X, y, y_pred):
        m = X.shape[0]

        dz2 = y_pred - y
        dW2 = (1/m) * np.dot(self.a1_dropout.T, dz2)
        db2 = (1/m) * np.sum(dz2, axis=0, keepdims=True)

        da1 = np.dot(dz2, self.W2.T)
        if self.training and self.dropout_rate > 0:
            da1 = da1 * self.dropout_mask

        dz1 = da1 * self.sigmoid_derivative(self.a1)
        dW1 = (1/m) * np.dot(X.T, dz1)
        db1 = (1/m) * np.sum(dz1, axis=0, keepdims=True)

        return dW1, db1, dW2, db2

    def set_training(self, training):
        self.training = training


# =====================================================
